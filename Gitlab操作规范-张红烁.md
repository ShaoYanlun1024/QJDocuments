# Gitlab规范

## 目录
- [issues模板](#issues模板)
- [issues操作规范](#issues操作规范)
- [标记操作规范](#标记操作规范)
- [commit模板](#commit模板)
- [请求合并模板](#请求合并模板)
- [分支命名规范](#分支命名规范)
- [里程碑命名规范](#里程碑命名规范)

## issues模板
```java
# 标题：/*总结问题（或被讨论）的主题*/
# 描述：/*问题（或议题）的详细表述，要求有上下文连带说明。*/
# 指派：/*对此问题的负责人*/
# 里程碑：
# 标记：/*每个Issues至少应该有三个Label，一个表示性质，一个表示优先级、另一个表示进度。*/
# 截止日期：/*计划日期*/
```
**`对于不同类型的Issues，有不同的填写模板。`**

#### **需求-Issue**
```
# 用一句话描述你的需求，并用它作为标题
# 这个需求是解决什么问题的？
# 这个需求对软件现有功能会造成什么影响？
# 这个需求应该实现什么样的功能？
# 这个需求是否依赖其他模块提供相关支持？
```
#### **错误报告-Issues**
```
<!--
    1. 请花点时间检查一下你的问题是否已存在。
    2. 请提供以下有关错误报告的所有相关信息，因为不完整的详细信息将作为无效报告处理。
-->
# 版本：【出现问题的软件版本号】
# 系统及运行环境：【浏览器各类、设备、操作系统】
# 期待的行为【清晰、简明地描述你期待的行为】
# 实际表现【清晰、简明地对实际的表现进行描述】
# 重现步骤【清晰地描述重现步骤，搭配截图】
```

>>>[**<p align="right">>>返回目录<<</p>**](#目录)

## Issues操作规范
#### **Review-Issue 并为其打上标签，关联到里程碑**
当 issue 被创建后，应该等待项目的 owner （owner 指项目的所有者，是对项目各方面都比较了解的人，可以为多个人） 对 issue 进行 Review。

Review 时，如果 owner 觉得这个 issue 满足下面的任意条件：

- 与项目本身的功能、市场定位有冲突
- 与现存 issue 有重复
- 其他不应该被保留的情况

则应该在评论中说明相关情况，并**关闭**该 issue。如果经过上面的过滤后，觉得 issue 应该被继续跟进，那就应该为它打上标签，方便之后的筛选、排期等工作。

除了为 issue 打上标签以外，你还可以为 issue 绑定上 milestone（里程碑），来将 issue 与某些特定的项目节点关联起来。之后便可以在 milestones 页面查看每一个里程碑的进展。

### **Issues 的后续操作**
当 issue 被创建、打上标签以后，就可以进行后续操作了。issue 的后续操作主要包括下面几种：

- `认领 issue`：每一个 issue 都有一个 Assignee（受理人），表示当前 issue 由谁在处理。在你准备开始具体的工作前，一定要记得将 issue 认领为自己所有。
- 在 `issue 下进行讨论`：在 issue 下可以围绕 issue 进行讨论，在讨论过程中，可以通过 @USERNAME 的方式通知其他人关注当前 issue。

### **勤于关闭 Issues**
随着项目越来越大，项目累积的 issue 也会越来越多。而这些 issue 中有很多已经失去它的价值。

所以，为了避免有价值的 issue 淹没在这些过时的信息当中，我们应该定期 Review 现有的 issues，由问题提出者关闭掉那些已经过时的 issues。

>>>[**<p align="right">>>返回目录<<</p>**](#目录)

## 标记操作规范
#### **问题性质**
- **Platform（平台）**：Web、Miniapp、App
- **Problems（问题）**：Bug（错误）、Security（安全）、Production（产品）
- **Mindless（待讨论）**：【分类待定，如：合理性、逻辑性、复杂度、规模、技术类调研等】
- **Environment（环境）**：Production（生产）、Test（测试）
- **Feedback（反馈）**：Question（问题）、RFC（请求意见稿）、UX（用户体验）、Discussion（讨论）、Suggest（建议）
- **Improvements（改进）**：Enhancement（增强）、Optimization（优化）
- **Additions（增加）**：Feature（功能）

#### **优先级**
- **VeryUrgent（十分紧急）**：对系统有重大影响，只有解决它之后，才能去完成其他任务。
- **Urgent（紧急）**：对系统的某个部分有影响，用户的一部分操作会达不到预期效果。
- **General（普通）**：对系统的某个部分有影响，用户几乎感知不到。
- **NotUrgent（不紧急）**：对系统的功能没有影响，通常是视觉效果不理想，比如字体和颜色不满意。

#### **进度状态**
- **ToDo（待安排）**
- **Plan（计划）**
- **Analysis（需求分析）**
- **UI（交互设计）**
- **Develop（开发）**
- **Test（测试）**
- **Deploy（部署）**
- **Doing（正在处理）**
- **On Hold（暂停）**
- **Duplicate（重复）**【可关闭Issues】
- **Wontifx（不用修复）**【可关闭Issues】
- **Resolved（已解决）**【可关闭Issues】
- **Done（已完成）**【可关闭Issues】

>>>[**<p align="right">>>返回目录<<</p>**](#目录)
## Commit模板
```Java
# 标题行：<类型 （范围）： 标题>/*50个汉字以内，描述主要变更内容*/
#/*<空行>*/
# 主体内容：/*更详细的说明文本，建议每行72个汉字以内。 */需要描述的信息包括:
#   * 为什么这个变更是必须的? 它可能是用来修复一个bug，增加一个feature，提升性能、可靠性、稳定性等等
#   * 如何解决这个问题? 具体描述解决问题的步骤
#   * 是否存在副作用、风险? 
#/*<空行>*/
# 尾部：/*如果需要的化可以添加一个链接到issue地址或者其它文档，或者关闭某个issue。*/
```

**一次Commit的格式规范，分成“`标题、内容详情、结尾`”三个部分**。

### **标题行**，即首行，是可以在页面中直接预览的部分，此部分包含三类信息：<`类型`>、<`范围`>和<`标题`>。

**# 类型：**
- feat：新功能（feature）
- fix：修补bug
- docs：文档（documentation）
- style： 格式（不影响代码运行的变动）
- refactor：重构（即不是新增功能，也不是修改bug的代码变动）
- perf：优化相关（比如提升性能、体验等）
- test：增加测试
- chore：构建过程或辅助工具的变动
- revert：回滚到上一个版本

`如果类型是feat和fix，则该commit将肯定出现在ChangeLog之中。`

**# 范围：**

用来说明本次Commit影响的范围，即简要说明修改会涉及的部分。

**# 标题：**

用来简要描述本次改动，并且遵循下面三条:
- 以动词开头，使用第一人称现在时
- 不要超过50个汉字
- 结尾不用句号(.)

### **主体**
这里的内容是对上面“标题”里内容的展开，在此做更加详尽的描述，内容里应该包含修改动机和修改前后的对比。

`请注意三点`：
1. 使用第一人称现在时
2. 应该说明代码变动的动机，以及与以前行为的对比。
3. 每行不超过72个汉字

### **结尾**
这里主要放置不兼容变更和Issues关闭的信息。

### **`Revert（还原）`**
如果需要撤销之前的Commit，那么本次Commit Message中必须以`revert:`开头，后面紧跟前面描述的Header部分，格式不变。并且，Body部分的格式也是固定的，必须要记录撤销前Commit的SHA值。

>>>[**<p align="right">>>返回目录<<</p>**](#目录)
## 请求合并模板
```java
<!--
    1. 确保你的目标是 "master" 分支，在 "release" 分支上的pull请求只允许进行错误修复
    2. 请提供以下信息，因为不完整的详细信息将作为无效报告处理。
    3. 描述你的拉取请求的作用以及你要定位的问题
-->
# 该 Pull Request 关联的 Issues
# 功能描述/*描述你的拉取请求的作用以及你要定位的问题*/
# 更新/*【示例: [X] Bug修复】*/
  - [ ] Bug修复（向后兼容的Bug修复）
  - [ ] 新功能（向后兼容的新增加功能）
  - [ ] 变化（和目前功能冲突的不兼容变化）
# 变化细节（checklist）
  - [ ] 测试单元代码1
  - [ ] 更新的文档1
# 其他需要注意事项
```
**`该分支包含哪些变化？ 该分支解决了哪些Bug/工单？ 如何测试这些变化代码？`**

**根据项目和工作流程，上传功能的截屏，或者链接到原型。**

>>>[**<p align="right">>>返回目录<<</p>**](#目录)
## 分支命名规范
Git分支分为五种类型：
- **master**：最为稳定功能最为完整的，随时可发布的代码
- hotfix：修复线上代码的Bug
- **develop**：永远是功能最新最全的分支
- feature：某个功能点正在开发阶段。**【以“feature-功能名”命名】**
- release：发布定期上线的功能

**Git分支与版本发布规范**
- 基本原则：master为保护分支，不直接在master上进行代码修改和提交。
- 开发日常需求或者项目时，从master分支上checkout一个feature分支进行开发或者bugfix分支进行bug修复，功能测试完毕并且项目发布上线后，将feature分支合并到主干master，并且打Tag发布，最后删除开发分支。`分支命名规范`：
  - 分支版本命名规则：分支类型 _ 分支发布时间 _ 分支功能。比如：feature_20170401_fairy_flower
  - 分支类型包括：feature、 bugfix、refactor三种类型，即新功能开发、bug修复和代码重构
  - 时间使用年月日进行命名，不足2位补0
  - 分支功能命名使用snake case命名法，即下划线命名。
- Tag包括3位版本，前缀使用v。比如v1.2.31。`Tag命名规范`：
  - 新功能开发使用第2位版本号，bug修复使用第3位版本号
  - 核心基础库或者Node中间价可以在大版本发布请使用灰度版本号，在版本后面加上后缀，用中划线分隔。alpha或者belta后面加上次数，即第几次alpha：
    - v2.0.0-alpha-1
    - v2.0.0-belta-1
- 版本正式发布前需要生成changelog文档，然后再发布上线。

>>>[**<p align="right">>>返回目录<<</p>**](#目录)
## 里程碑命名规范：
```java
# 标题：/*活动简述*/
# 描述：/*用户故事*/
# 开始日期：/*计划日期*/
# 截止日期：/*计划日期*/
```
描述（用户故事三要素）：
1. 角色：谁要使用这个功能。
2. 活动：需要完成什么样的功能。
3. 商业价值：为什么需要这个功能，这个功能带来什么样的价值。

**作为一个<角色>, 我想要<活动>, 以便于实现<商业价值>**

>`举例：`
>作为一个“网站管理员”，我想要“统计每天有多少人访问了我的网站”，以便于“我的赞助商了解我的网站会给他们带来什么收益。”
>
**`需要注意的是用户故事不能够使用技术语言来描述，要使用用户可以理解的业务语言来描述。`**

>>>[**<p align="right">>>返回目录<<</p>**](#目录)